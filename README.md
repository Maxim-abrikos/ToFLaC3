# ToFLaC3
Третья лабораторная по теории формальных языков и компиляторов  
I. Постановка задачи  
В C# для объявления и инициализации комплексного числа используется структура System.Numerics.Complex. Эта структура позволяет представить комплексное число как пару чисел с плавающей точкой, представляющих действительную и мнимую части. После объявления переменной типа Complex, ей можно присвоить значение, представляющее комплексное число, которое в дальнейшем не будет изменяться (хотя сама переменная может быть переназначена).
Формат записи: “Complex $name = new Complex ($value, $value);”
Параметр $name передает имя переменной, а параметр $value - ее значения. Значение может быть целым (int), дробным (float, double, exp).
Примеры:  
1.	Complex Perem = new Complex (2, 0);  
2.	Complex Perem = new Complex (3.4, -5.7f);   
3.	Complex Perem = new Complex (1.23e-4f, 1.23e-4f);    	
 
II. Разработка грамматики  
Определим грамматику объявления и инициализации комплексного числа на языке C# G[<DEF>] в нотации Хомского с продукциями P:  
1.	<DEF> → ‘Complex’•IDENT 
2.	IDENT → letter•IDREM  
3.	IDREM → letter • IDREM | digit• IDREM| _IDREM| ‘=’NEW  
4.	NEW → ‘new’•TYPE  
5.	TYPE → ‘Complex’•CONSTRUCTOR  
6.	CONSTRUCTOR → ‘(’ •SIGN  
7.	SIGN → ‘-’ •NUMBERS | NUMBERS  
8.	NUMBERS → digit • NUM  
9.	NUM → digit • REAL | ‘.’REAL | ‘,’ IMAGINARY  
10.	REAL → digit • REALREM  
11.	REALREM → digit•REALREM | ‘,’IMAGINARYSIGN  
12.	IMAGINARYSIGN → IMAGINARY | ‘-’ • IMAGINARY  
13.	IMAGINARY → digit • INTIMAGINARY  
14.	INTIMAGINARY → digit • INTIMAGINARY| ‘.’INTIMAGINARYREM | ‘)’ •END  
15.	INTIMAGINARYREM → digit • INTIMAGINARYREM | ‘)’ •END  
16.	END → ‘;’  
17.	<letter> → "a" | "b" | "c" | ... | "z" | "A" | "B" | "C" | ... | "Z" |  
<digit> → "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"    
Следуя введенному формальному определению грамматики, представим G[<DEF>] ее составляющими:
•	Z = G[<DEF >] ;
•	VT = {a, b, c, ..., z, A, B, C, ..., Z, +, -, ;, ,, .,0, 1, 2, ..., 9};
•	VN = {<DEF>, <IDENT>, <IDREM>, <NEW>, <TYPE>, <CONSTRUCTOR>, <SIGN>, <NUMBERS>,<NUM>, <REAL>, <REALREM>, < IMAGINARYSIGN >, <IMAGINARY>, <INTIMAGINARY>, <IMAGINARYREM>, <END>}
III. Классификация грамматики  
Н. Хомский выделил четыре класса грамматик: грамматики нулевого типа, контекстно-зависимые, контекстно-свободные и автоматные грамматики. Вид грамматики определяется исходя из формы записи ее правил.
Грамматики нулевого типа имеют правила следующего вида:
α→β,
где α ∈ V*, V = Vт ⋃ VN, β ∈ V*.
Контекстно-зависимые грамматики (КЗграмматики) имеют правила следующего вида:
γ1Aγ2 → γ1βγ2,
где A ∈ VN, β∈V+, γ1∈V* и γ2∈V*.
Контекстно-свободные грамматики имеют правила следующего вида:
A → a,
где A∈VN, α∈V*.
Автоматные или регулярные грамматики имеют самые строгие ограничения на форму записи правил:
A → aB | a | ε,
где a∈VТ, A∈VN и B∈VB.
Согласно приведённым выше правилам, грамматика G[<DEF>] является автоматной грамматикой, т.к. здесь в левой части правил находится только по одному нетерминальному символу, а в правой – либо один терминальный и один нетерминальный символ, либо один терминальный символ.  
 
IV. Метод анализа  
Для анализа грамматики было выбрано её представление в виде графа конечного автомата (рис. 1), где состояние 1 – является начальным, а состояние 15 – конечным.  
 
![image](https://github.com/user-attachments/assets/dea571b8-7d57-4685-b6d0-be95254b4821)  

Рисунок 1 – Граф конечного автомата грамматики G[‹DEF›]  
 
V. Диагностика и нейтрализация синтаксических ошибок  
Для нашей программы необходимо реализовать нейтрализацию ошибок.  
Проверка производится поэтапно:  
1)	Сначала программа посимвольно проверяет строку на наличие запрещённых символов. Программа помечает “проблемные” места, где находятся подстроки запрещённых символов, затем удаляет их и соединяет оставшиеся подстроки. Все удалённые подстроки заносятся в список ошибок.
2)	Программа возвращается в начало строки и движется уже не по символам, а по токенам. Токеном может быть число, символ и слово. Далее программа проходит по токенам и сравнивает полученный с ожидаемым. Если они совпали, то программа идёт дальше. Если нет, то: программа идёт до конца строки в поисках нужного токена. Если такой найден, то все токены между ним и предыдущим обязательным отбрасываются с пометкой об их ошибочности. В противном случае программа обозначит искомый токен пропущенные и перейдёт к поиску следующего.  
VI. Тестовые примеры  
На рисунках 2-7 представлены тестовые примеры запуска разработанного синтаксического анализатора объявления и инициализации комплексного числа на языке C#.  
 ![image](https://github.com/user-attachments/assets/00e66943-7e85-466b-b0fc-046408492947)  
Рисунок 2 – Тестовый пример 1  

![image](https://github.com/user-attachments/assets/1dc39dcb-4857-45a9-a7fe-393af5f3669a)  
Рисунок 3 – Тестовый пример 2  

![image](https://github.com/user-attachments/assets/3e4eb9c3-5e4e-475c-b852-66c70f221f91)  
Рисунок 4 – Тестовый пример 3  

![image](https://github.com/user-attachments/assets/fb3f9d0c-399d-46d1-b46b-5bc4918eeaf9)  
Рисунок 5 – Тестовый пример 4  

![image](https://github.com/user-attachments/assets/d6bf586a-7173-4007-8d2a-867dbefdf80a)  
Рисунок 6 – Тестовый пример 5  

![image](https://github.com/user-attachments/assets/98b8b711-804d-45f3-83da-fb0c365fb2a9)  
Рисунок 7 – Тестовый пример 6
